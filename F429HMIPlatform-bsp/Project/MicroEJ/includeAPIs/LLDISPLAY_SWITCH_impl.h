/* 
 * Copyright 2011-2013 IS2T. All rights reserved.
 * Modification and distribution is permitted under certain conditions.
 * IS2T PROPRIETARY/CONFIDENTIAL. Use is subject to license terms.
 */
/* 
 * AUTOGENERATED by COMP-ICETEA-ARMCC-ARM - 1.0.0 - DO NOT EDIT IT
 */
/* 
 * Implementation header file. Shall only be included by client implementation C files.
 */
#include <LLDISPLAY_SWITCH.h>
#include <stdint.h>
#include <intern/LLDISPLAY_SWITCH_impl.h>
#ifndef LLDISPLAY_SWITCH_IMPL
#warning "Implementation tag has not been defined. Default implementation tag is LLDISPLAY_SWITCH_IMPL"
#endif
// --------------------------------------------------------------------------------
// -                      Functions that must be implemented                      -
// --------------------------------------------------------------------------------

/**
 * Initialize the display. 
 * @return 1 when the initialization has been completed
 */
uint8_t LLDISPLAY_SWITCH_IMPL_initialize(LLDISPLAY_SWITCH* env);

/**
 * Gets the display's width in pixels.<br>
 * The LOGICAL size is the one reported to the application.<br>
 * The PHYSICAL size takes alignment constraints into account : there may be
 * unused pixels between each line of the display.<br>
 * <br>
 * It is a constraint that PHYSICAL >= LOGICAL
 * @param logical 1 for LOGICAL, 0 for PHYSICAL
 * @return the display's width in pixels. 
 */
int32_t LLDISPLAY_SWITCH_IMPL_getWidth(LLDISPLAY_SWITCH* env, uint8_t logical);

/**
 * Gets the display's height in pixels.<br>
 * The LOGICAL size is the one reported to the application.<br>
 * The PHYSICAL size takes alignment constraints into account : there may be
 * unused pixels between each line of the display.<br>
 * <br>
 * It is a constraint that PHYSICAL >= LOGICAL
 * @param logical 1 for LOGICAL, 0 for PHYSICAL
 * @return the display's height in pixels. 
 */
int32_t LLDISPLAY_SWITCH_IMPL_getHeight(LLDISPLAY_SWITCH* env, uint8_t logical);

/**
 * Converts the 24-bit RGB color format (0-R-G-B) into the display color format.
 * @return the converted color
 */
int32_t LLDISPLAY_SWITCH_IMPL_convertRGBColorToDisplayColor(LLDISPLAY_SWITCH* env, int32_t color);

/**
 * Converts the display color format into a 24-bit RGB color format (0-R-G-B).
 * @return the converted color
 */
int32_t LLDISPLAY_SWITCH_IMPL_convertDisplayColorToRGBColor(LLDISPLAY_SWITCH* env, int32_t color);

/**
 * Sets the new contrast.
 * @param contrast a value between 0 and 100
 */
void LLDISPLAY_SWITCH_IMPL_setContrast(LLDISPLAY_SWITCH* env, int32_t contrast);

/**
 * Gets the current contrast.
 * @return a value between 0 and 100
 */
int32_t LLDISPLAY_SWITCH_IMPL_getContrast(LLDISPLAY_SWITCH* env);

/**
 * Sets the new backlight value.
 * @param backlight a value between 0 and 100
 */
void LLDISPLAY_SWITCH_IMPL_setBacklight(LLDISPLAY_SWITCH* env, int32_t backLight);

/**
 * Returns 1 when the display module can manage the display backlight.
 */
uint8_t LLDISPLAY_SWITCH_IMPL_hasBackLight(LLDISPLAY_SWITCH* env);

/**
 * Gets the current backlight value.
 * @return a value between 0 and 100
 */
int32_t LLDISPLAY_SWITCH_IMPL_getBacklight(LLDISPLAY_SWITCH* env);

/**
 * Turns on the backlight.
 */
void LLDISPLAY_SWITCH_IMPL_backlightOn(LLDISPLAY_SWITCH* env);

/**
 * Turns off the backlight.
 */
void LLDISPLAY_SWITCH_IMPL_backlightOff(LLDISPLAY_SWITCH* env);

/**
 * Gets an adjustment to apply to font pixels that are neither fully transparent nor fully opaque.
 * The adjustment is added to each color component of the pixels, so a positive value makes the
 * pixels lighter, a negative value makes them darker.
 * @param bpp the number of bits-per-pixel of the font for which the adjustment is needed
 * @return pixel color adjustment value
 */
int32_t LLDISPLAY_SWITCH_IMPL_getFontAlphaAdjustment(LLDISPLAY_SWITCH* env, int32_t bpp);

/**
 * Returns the start address of the buffer used to store the display stack's heap.
 * The heap can contain:
 * <ul>
 * <li>the draw polygon algorithm working buffers,</li>
 * <li>the dynamic user images,</li>
 * <li>the working buffers and the decoded images of embedded image decoders (for instance the PNG decoder)</li>
 * </ul>
 * A too small value can cause OutOfMemory errors and incomplete drawings. <br>
 * Ensure the heap start address is aligned on 32 bits or ensure the CPU can manupulates unaligned memory
 * addresses. 
 * @return the working buffer start address
 */
int32_t LLDISPLAY_SWITCH_IMPL_getWorkingBufferStartAddress(LLDISPLAY_SWITCH* env);

/**
 * Returns the end address of the buffer used to store the display stack's heap.
 * @see LLDISPLAY_SWITCH_getWorkingBufferStartAddress
 * @return the working buffer end address
 */
int32_t LLDISPLAY_SWITCH_IMPL_getWorkingBufferEndAddress(LLDISPLAY_SWITCH* env);

/**
 * Asks if the diplay is a grayscale display or not. 
 * @return 1 when the display is not a grayscale display
 */
uint8_t LLDISPLAY_SWITCH_IMPL_isColor(LLDISPLAY_SWITCH* env);

/**
 * Returns the number of colors the display can display.<br>
 * Usually the number of colors is <code>1 << BPP - 1</code>
 * @return the number of colors the display can display.
 */
int32_t LLDISPLAY_SWITCH_IMPL_getNumberOfColors(LLDISPLAY_SWITCH* env);

/**
 * Synchronizes the display stack drawing with the display framerate.<br>
 * This method is called by the display stack before the very first drawing
 * after a flush. This allows to the display driver to wait for the right
 * moment to allow the display stack to start using the back buffer
 * in order to avoid flickering.<br>
 * This method is optional and can do nothing.
 */
void LLDISPLAY_SWITCH_IMPL_synchronize(LLDISPLAY_SWITCH* env);

/**
 * Returns the address of the buffer which is used initially by the display to refresh
 * itself. 
 * @return the buffer address
 */
int32_t LLDISPLAY_SWITCH_IMPL_getDisplayBufferAddress(LLDISPLAY_SWITCH* env);

/**
 * Returns the address of the initial back buffer. This buffer will be the first buffer
 * used by the display stack for application drawing.
 * @return the buffer address
 */
int32_t LLDISPLAY_SWITCH_IMPL_getBackBufferAddress(LLDISPLAY_SWITCH* env);

/**
 * Sets the new display buffer address to the supplied addr. The buffers are swapped: 
 * the existing display buffer becomes the new back buffer and the supplied addr becomes 
 * the new display buffer.<br>
 * After the swap the implementation must copy the content of the new display buffer 
 * into the new back buffer. The rectangle specified by (xmin, ymin) to (xmax, ymax) is 
 * the region which has changed during last draw and only this region should be copied.<br>
 * @param addr the new display buffer address 
 */
void LLDISPLAY_SWITCH_IMPL_setDisplayBufferAddress(LLDISPLAY_SWITCH* env, int32_t addr, int32_t xmin, int32_t ymin, int32_t xmax, int32_t ymax);
