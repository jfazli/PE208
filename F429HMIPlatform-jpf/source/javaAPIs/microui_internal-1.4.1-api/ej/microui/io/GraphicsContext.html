<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc (build 1.6.0_29) on Tue Oct 01 12:18:43 CEST 2013 -->
<TITLE>
GraphicsContext
</TITLE>

<META NAME="date" CONTENT="2013-10-01">

<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">

<SCRIPT type="text/javascript">
function windowTitle()
{
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="GraphicsContext";
    }
}
</SCRIPT>
<NOSCRIPT>
</NOSCRIPT>

</HEAD>

<BODY BGCOLOR="white" onload="windowTitle();">
<HR>


<!-- ========= START OF TOP NAVBAR ======= -->
<A NAME="navbar_top"><!-- --></A>
<A HREF="#skip-navbar_top" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GraphicsContext.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../ej/microui/io/Font.html" title="class in ej.microui.io"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?ej/microui/io/GraphicsContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphicsContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_top"></A>
<!-- ========= END OF TOP NAVBAR ========= -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
ej.microui.io</FONT>
<BR>
Class GraphicsContext</H2>
<PRE>
java.lang.Object
  <IMG SRC="../../../resources/inherit.gif" ALT="extended by "><B>ej.microui.io.GraphicsContext</B>
</PRE>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../ej/microui/io/ExplicitFlush.html" title="class in ej.microui.io">ExplicitFlush</A></DD>
</DL>
<HR>
<DL>
<DT><PRE>public class <B>GraphicsContext</B><DT>extends java.lang.Object</DL>
</PRE>

<P>
The <code>GraphicsContext</code> class offers basic drawing facilities,
 to render lines, rectangles, polygons, arcs and text.<br>
 <br>
 <code>GraphicsContext</code> uses 24-bit RGB color. Each color:
 red, green and blue is defined with an 8-bit value. <br>
 Not all displays may support such color depth. Therefore the implementation is in charge
 of mapping application colors to the most appropriate available colors.<br>
 <br>
 A <code>GraphicsContext</code> object may be used either to
 <ul>
 <li>paint on a display in the "normal" rendering procedure (using <code>paint(GraphicsContext)</code>
 methods), or</li>
 <li>draw on a mutable image, or</li>
 <li>directly draw on a display bypassing the "normal" rendering mechanism.</li>
 </ul>
 When a visible object (for instance a <code>Viewable</code> or a <code>View</code>) has
 to be painted on a <code>Display</code>, the <code>paint</code> method is given a
 <code>GraphicsContext</code> as argument and should use it to render the visible object.<br>
 <br>
 A <code>GraphicsContext</code> may be requested for a mutable image. This graphics context
 can be used to draw in the image.<br>
 <br>
 Direct drawing on a display can be done from application by retrieving a
 <code>GraphicsContext</code> with <A HREF="../../../ej/microui/io/Display.html#getNewGraphicsContext()"><CODE>Display.getNewGraphicsContext()</CODE></A> or <A HREF="../../../ej/microui/io/Display.html#getNewExplicitFlush()"><CODE>Display.getNewExplicitFlush()</CODE></A>.
 Using this mechanism does not ensure drawings will be performed before, during or after the
 current <code>paint()</code>, since it bypasses the serialization system events.<br>
 <br>
 Drawing text relies on available fonts. Text can be drawn using <A HREF="../../../ej/microui/io/GraphicsContext.html#drawChar(char, int, int, int)"><CODE>drawChar</CODE></A>,
 <CODE>drawChars</CODE>, <A HREF="../../../ej/microui/io/GraphicsContext.html#drawString(java.lang.String, int, int, int)"><CODE>drawString</CODE></A> or
 <A HREF="../../../ej/microui/io/GraphicsContext.html#drawSubstring(java.lang.String, int, int, int, int, int)"><CODE>drawSubstring</CODE></A>. Characters are drawn with the current color
 of the <code>GraphicsContext</code> object.<br>
 <br>
 The coordinate system is as follows:
 <ul>
 <li>origin is at the upper left corner of the destination.</li>
 <li>X-axis is positive towards the right.</li>
 <li>Y-axis is positive downwards.</li>
 </ul>
 A coordinate does not map a pixel, but rather the location between pixels.
 For instance, the first pixel in the upper left corner matches a square
 of coordinates: <code>(0,0), (1,0), (1,1) and (0,1)</code>.
 The call (where g is a <code>GraphicsContext</code>) <code>g.fillRect(1,0,2,3)</code>
 paints six pixels.<br>
 <br>
 Two different stroke styles may be used when drawing lines, arcs or rectangles: either
 <code>SOLID</code> or <code>DOTTED</code>. Stroke style has no effect on fill, text and
 image handling.<br>
 <br>
 The <code>SOLID</code> stroke style allows drawing with a one-pixel wide pen.
 Drawing at a specific coordinate fills the adjacent down-right pixel.
 For instance, although the next line has a width of 1,
 <code>g.drawLine(0,0,1,0)</code>
 draws 2 pixels: the upper-left corner of the display and its adjacent right pixel. <br>
 <br>
 The <code>DOTTED</code> stroke style allows drawing a subset of the pixels that would have been
 drawn with the <code>SOLID</code> stroke style. Length and frequency of dots is implementation
 dependent and, as a result, so are the drawn pixels.
 Note that end of lines or end of arcs, as well as the corner of rectangles may not be drawn with the
 <code>DOTTED</code> stroke style.<br>
 <br>
 One important remark has to be made about rectangle drawing and filling.
 Drawing a rectangle with the code:<br>
 <code>drawRect(x,y,w,h);</code><br>
 is equivalent to the following code sequence:<br>
 <code>drawLine(x,y,x+w,y);</code><br>
 <code>drawLine(x+w,y,x+w,y+h);</code><br>
 <code>drawLine(x+w,y+h,x,y+h);</code><br>
 <code>drawLine(x,y+h,x,y);</code><br>
 <br>
 In addition, the following code:<br>
 <code>fillRect(x,y,w,h);</code><br>
 results in filling rectangle area which differs from the rectangle drawn by <code>drawRect(x,y,w,h)</code>.
 Indeed, the filled area counts <code>w*h</code> pixels, whereas the area delimited by <code>drawRect(x,y,w,h)</code>
 counts <code>(w+1)*(h+1)</code> pixels.<br>
 A filled area must overlap exactly or be contiguous to its matching drawn area.
 That is to say that there must be no blank space between a filled area and its matching drawn area and that
 the filled area must not be out of the bounds of the drawn area.<br>
 <br>
 Note that the exact number of pixels drawn by <code>drawLine()</code> and <code>drawArc()</code> are
 implementation dependent.<br>
 <br>
 A <code>GraphicsContext</code> defines a clipping zone which specifies the destination area that can be modified
 by calls to the <code>GraphicsContext</code>. The clipping zone can be set by the
 application but is more commonly set by the UI framework. The clipping zone may be empty (i.e. its size is zero),
 in that case, every rendering operation will have no effect. It may also be out of the bounds of the destination,
 in which case every rendering operation out of the range of the destination is ignored.
 Modification of the coordinate system (with the method <code>translate</code> for instance) has no effect on the clipping zone.<br>
 <br>
 When positioning a visible object (text or image for instance) into a drawable area, a coordinate <code>(x,y)</code>
 location or anchor point is used.
 In addition it is possible to express how the object is set around the anchor point.
 Several constants have been thus defined; they can be combined bit-wise to precisely
 define how the object is set around the anchor point.
 For instance,<br>
 <br>
 <code>g.drawString("test",x,y,TOP|LEFT);</code><br>
 <br>
 draws a string and defines <code>(x,y)</code> as the upper left point of the text zone.<br>
 <br>
 <code>g.drawString("test",x,y,TOP|HCENTER);</code><br>
 <br>
 will draw string <code>"test"</code> above and centered on <code>(x,y)</code>.<br>
 <br>
 Note that any anchor constants combination must be limited to one of the horizontal constants
 (<code>LEFT</code>, <code>HCENTER</code>, <code>RIGHT</code>) and one of the vertical constants
 (<code>TOP</code>, <code>BASELINE</code> for text positioning exclusively, <code>VCENTER</code>, <code>BOTTOM</code>).
 The default anchor position, obtained with value <code>0</code>, matches the <code>TOP | LEFT</code> constant combination.
<P>

<P>
<HR>

<P>
<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Field Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#AND">AND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>AND</code> operator on the filter.<br>
 <br>
 Value <code>4</code> is assigned to <code>AND</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#BASELINE">BASELINE</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the baseline of the text at the anchor point.<br>
 <br>
 Value <code>64</code> is assigned to <code>BASELINE</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#BOTTOM">BOTTOM</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the bottom of the drawing at the anchor point.<br>
 <br>
 Value <code>32</code> is assigned to <code>BOTTOM</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#DOTTED">DOTTED</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>DOTTED</code> stroke style.<br>
 <br>
 Value <code>1</code> is assigned to <code>DOTTED</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#HCENTER">HCENTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for centering drawing horizontally around the anchor point.<br>
 <br>
 Value <code>1</code> is assigned to <code>HCENTER</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#INV_COLOR">INV_COLOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>INV_COLOR</code> operator mask on the filter.<br>
 <br>
 Value <code>0x10</code> is assigned to <code>INV_COLOR</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#INV_RESULT">INV_RESULT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>INV_RESULT</code> operator mask on the filter.<br>
 <br>
 Value <code>0x20</code> is assigned to <code>INV_RESULT</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#LEFT">LEFT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the left side of the drawing at the anchor point.<br>
 <br>
 Value <code>4</code> is assigned to <code>LEFT</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#MINUS">MINUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>MINUS</code> operator on the filter.<br>
 <br>
 Value <code>2</code> is assigned to <code>MINUS</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#OR">OR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>OR</code> operator on the filter.<br>
 <br>
 Value <code>3</code> is assigned to <code>OR</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#PLUS">PLUS</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>PLUS</code> operator on the filter.<br>
 <br>
 Value <code>1</code> is assigned to <code>PLUS</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#RESET_FILTER">RESET_FILTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant to apply any filter on the color.<br>
 <br>
 Value <code>0</code> is assigned to <code>RESET_FILTER</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#RIGHT">RIGHT</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the right side of the drawing at the anchor point.<br>
 <br>
 Value <code>8</code> is assigned to <code>RIGHT</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#SOLID">SOLID</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>SOLID</code> stroke style.<br>
 <br>
 Value <code>0</code> is assigned to <code>SOLID</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#TOP">TOP</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for positioning the top of the drawing at the anchor point.<br>
 <br>
 Value <code>16</code> is assigned to <code>TOP</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#VCENTER">VCENTER</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for centering the drawing vertically around the anchor point.<br>
 <br>
 Value <code>2</code> is assigned to <code>VCENTER</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#XOR">XOR</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constant for the <code>XOR</code> operator on the filter.<br>
 <br>
 Value <code>5</code> is assigned to <code>XOR</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#GraphicsContext()">GraphicsContext</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Forbidden constructor: use <A HREF="../../../ej/microui/io/Display.html#getNewGraphicsContext()"><CODE>Display.getNewGraphicsContext()</CODE></A>
 to get an instance of <code>GraphicsContext</code>.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="2"><FONT SIZE="+2">
<B>Method Summary</B></FONT></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#clipRect(int, int, int, int)">clipRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the clipping area to be the intersection of the specified rectangle
 with the current clipping rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#copyArea(int, int, int, int, int, int, int)">copyArea</A></B>(int&nbsp;x_src,
         int&nbsp;y_src,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;x_dest,
         int&nbsp;y_dest,
         int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Copies an area within a <code>GraphicsContext</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawArc(int, int, int, int, int, int)">drawArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of a circular or elliptical arc covering the specified
 rectangle, using the current color and stroke style.<br>
 <br>
 The arc is drawn from <code>startAngle</code> up to <code>arcAngle</code> degrees.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawARGB(int[], int, int, int, int, int, int, int)">drawARGB</A></B>(int[]&nbsp;argbData,
         int&nbsp;offset,
         int&nbsp;scanlength,
         int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height,
         int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets ARGB pixel data from the provided array of integers and draws it in the specified region of this graphics
 context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawChar(char, int, int, int)">drawChar</A></B>(char&nbsp;character,
         int&nbsp;x,
         int&nbsp;y,
         int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a character using the current font and color.<br>
 The text anchor point is at position <code>(x,y)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawCircle(int, int, int)">drawCircle</A></B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;diameter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of a circle covering the rectangle specified by its diameter, using the current color
 and stroke style.<br>
 <br>
 The center of the circle is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>diameter</code>.<br>
 <br>
 If <code>diameter</code> is negative, nothing is drawn.<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawDeformedImage(ej.microui.io.Image, int, int, int[], int)">drawDeformedImage</A></B>(<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io">Image</A>&nbsp;img,
                  int&nbsp;x,
                  int&nbsp;y,
                  int[]&nbsp;xys,
                  int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a deformed image at the given anchor point.<br>
 The image anchor point is at position <code>(x,y)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawEllipse(int, int, int, int)">drawEllipse</A></B>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of a ellipse covering the specified rectangle, using the current color
 and stroke style.<br>
 <br>
 The center of the ellipse is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 <br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawHorizontalLine(int, int, int)">drawHorizontalLine</A></B>(int&nbsp;x,
                   int&nbsp;y,
                   int&nbsp;width)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an horizontal line from <code>(x,y)</code> to <code>(x+width,y)</code> using
 the current color and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawImage(ej.microui.io.Image, int, int, int)">drawImage</A></B>(<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io">Image</A>&nbsp;img,
          int&nbsp;x,
          int&nbsp;y,
          int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws an image at the given anchor point.<br>
 The image anchor point is at position <code>(x,y)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawLine(int, int, int, int)">drawLine</A></B>(int&nbsp;x1,
         int&nbsp;y1,
         int&nbsp;x2,
         int&nbsp;y2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a line from <code>(x1,y1)</code> to <code>(x2,y2)</code> using the current
 color and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawPixel(int, int)">drawPixel</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a pixel at <code>(x,y)</code> using the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawPolygon(int[])">drawPolygon</A></B>(int[]&nbsp;xys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the closed polygon which is defined by the array of integer coordinates, using the current color and
 stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawPolygon(int[], int, int)">drawPolygon</A></B>(int[]&nbsp;xys,
            int&nbsp;offset,
            int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the closed polygon which is defined by the array of integer coordinates, using the current color and
 stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawRect(int, int, int, int)">drawRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of the specified rectangle using the current color and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawRegion(ej.microui.io.Image, int, int, int, int, int, int, int)">drawRegion</A></B>(<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io">Image</A>&nbsp;src,
           int&nbsp;x_src,
           int&nbsp;y_src,
           int&nbsp;width,
           int&nbsp;height,
           int&nbsp;x_dest,
           int&nbsp;y_dest,
           int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the specified region of an image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawRoundRect(int, int, int, int, int, int)">drawRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the outline of the specified rounded corner rectangle using the
 current color and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawString(java.lang.String, int, int, int)">drawString</A></B>(java.lang.String&nbsp;str,
           int&nbsp;x,
           int&nbsp;y,
           int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the string using the current font and color.<br>
 The text anchor point is at position <code>(x,y)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawSubstring(java.lang.String, int, int, int, int, int)">drawSubstring</A></B>(java.lang.String&nbsp;str,
              int&nbsp;offset,
              int&nbsp;len,
              int&nbsp;x,
              int&nbsp;y,
              int&nbsp;anchor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws the string from <code>offset</code> to <code>offset+length</code> using the current font and color.<br>
 The text anchor point is at position <code>(x,y)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#drawVerticalLine(int, int, int)">drawVerticalLine</A></B>(int&nbsp;x,
                 int&nbsp;y,
                 int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Draws a vertical line from <code>(x,y)</code> to <code>(x,y+height-1)</code> using
 the current color and stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillArc(int, int, int, int, int, int)">fillArc</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height,
        int&nbsp;startAngle,
        int&nbsp;arcAngle)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a circular or elliptical arc covering the specified rectangle with the current color.<br>
 <br>
 The arc is drawn from <code>startAngle</code> up to <code>arcAngle</code> degrees.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillCircle(int, int, int)">fillCircle</A></B>(int&nbsp;x,
           int&nbsp;y,
           int&nbsp;diameter)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a circle covering the rectangle specified by its diameter with the current color.<br>
 <br>
 The center of the circle is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>diameter</code>.<br>
 <br>
 If <code>diameter</code> is negative, nothing is drawn.<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillEllipse(int, int, int, int)">fillEllipse</A></B>(int&nbsp;x,
            int&nbsp;y,
            int&nbsp;width,
            int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills a ellipse covering the specified rectangle with the current color.<br>
 <br>
 The center of the ellipse is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 <br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillPolygon(int[])">fillPolygon</A></B>(int[]&nbsp;xys)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the closed polygon which is defined by the array of integer coordinates, using the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillPolygon(int[], int, int)">fillPolygon</A></B>(int[]&nbsp;xys,
            int&nbsp;offset,
            int&nbsp;length)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the closed polygon which is defined by the array of integer coordinates, using the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillRect(int, int, int, int)">fillRect</A></B>(int&nbsp;x,
         int&nbsp;y,
         int&nbsp;width,
         int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified rectangle with the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#fillRoundRect(int, int, int, int, int, int)">fillRoundRect</A></B>(int&nbsp;x,
              int&nbsp;y,
              int&nbsp;width,
              int&nbsp;height,
              int&nbsp;arcWidth,
              int&nbsp;arcHeight)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fills the specified rounded corner rectangle with the current color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getARGB(int[], int, int, int, int, int, int)">getARGB</A></B>(int[]&nbsp;argbData,
        int&nbsp;offset,
        int&nbsp;scanlength,
        int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains ARGB pixel data from the specified region of this graphics context and stores it
 in the provided array of integers.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getClipHeight()">getClipHeight</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the height of the current clipping zone.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getClipWidth()">getClipWidth</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the width of the current clipping zone.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getClipX()">getClipX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x offset of the current clipping zone, relative to the graphics context's origin.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getClipY()">getClipY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y offset of the current clipping zone, relative to graphics context's origin.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getColor()">getColor</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current color: a 24-bits value interpreted as: <code>0xRRGGBB</code>,
 that is, the eight least significant bits give the blue color, the next eight
 bits the green value and the next eight bits the red color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ej/microui/io/Display.html" title="class in ej.microui.io">Display</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getDisplay()">getDisplay</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the display associated with the GraphicsContext.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getDisplayColor(int)">getDisplayColor</A></B>(int&nbsp;color)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets the color that will be displayed if the specified color is requested.<br>
 For example, with a monochrome display, this method will return either 0xFFFFFF (white) or
 0x000000 (black) depending on the brightness of the specified color.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getEllipsis()">getEllipsis</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the truncation mechanism is enabled.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getFilter(int, int)">getFilter</A></B>(int&nbsp;rgbFilter,
          int&nbsp;factor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Gets a filter from the given filter and the given factor.<br>
 Given value <code>rgbFilter</code> is interpreted as a 24-bit RGB,
 where the eight least significant bits matches the blue component, the next eight
 more significant bits matches the green component and the next eight more significant
 bits matches the red component.<br>
 Each component of this filter is multiplied by the factor and the result is saturate to 0xff.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../ej/microui/io/DisplayFont.html" title="class in ej.microui.io">DisplayFont</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getFont()">getFont</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current font.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getStrokeStyle()">getStrokeStyle</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the current stroke style.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getTranslateX()">getTranslateX</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the x coordinate of the translated origin of the graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#getTranslateY()">getTranslateY</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the y coordinate of the translated origin of the graphics context.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#readPixel(int, int)">readPixel</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Obtains the RGB color of the pixel at <code>(x,y)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#setClip(int, int, int, int)">setClip</A></B>(int&nbsp;x,
        int&nbsp;y,
        int&nbsp;width,
        int&nbsp;height)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current clipping zone to the rectangle defined by the given location
 <code>(x,y)</code> and size <code>(width,height)</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#setColor(int)">setColor</A></B>(int&nbsp;rgbColor)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current color.<br>
 Given value <code>rgbColor</code> is interpreted as a 24-bit RGB color,
 where the eight least significant bits matches the blue component, the next eight
 more significant bits matches the green component and the next eight more significant
 bits matches the red component.<br></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#setEllipsis(boolean)">setEllipsis</A></B>(boolean&nbsp;enable)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Enables (disables) truncation when rendering characters.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)">setFilter</A></B>(int&nbsp;rgbFilter,
          int&nbsp;operator)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the current filter.<br>
 Given value <code>rgbFilter</code> is interpreted as a 24-bit RGB,
 where the eight least significant bits matches the blue component, the next eight
 more significant bits matches the green component and the next eight more significant
 bits matches the red component.<br>
 The filter is applied on each pixel drawn.<br>
 The operator is a combinaison between a binary operator and two unary operators:
 
 binary operators are:
 
 PLUS: perform a saturated addition between each color component (R, G, and B) and each
 corresponded filter component.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#setFont(ej.microui.io.DisplayFont)">setFont</A></B>(<A HREF="../../../ej/microui/io/DisplayFont.html" title="class in ej.microui.io">DisplayFont</A>&nbsp;font)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the font for subsequent text operations.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#setStrokeStyle(int)">setStrokeStyle</A></B>(int&nbsp;style)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the stroke style of the <code>GraphicsContext</code> used for drawing lines, arcs and rectangles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../ej/microui/io/GraphicsContext.html#translate(int, int)">translate</A></B>(int&nbsp;x,
          int&nbsp;y)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Translates the <code>GraphicsContext</code> origin with the given vector <code>(x,y)</code>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TH ALIGN="left"><B>Methods inherited from class java.lang.Object</B></TH>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE>equals, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Field Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="HCENTER"><!-- --></A><H3>
HCENTER</H3>
<PRE>
public static final int <B>HCENTER</B></PRE>
<DL>
<DD>Constant for centering drawing horizontally around the anchor point.<br>
 <br>
 Value <code>1</code> is assigned to <code>HCENTER</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.HCENTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="VCENTER"><!-- --></A><H3>
VCENTER</H3>
<PRE>
public static final int <B>VCENTER</B></PRE>
<DL>
<DD>Constant for centering the drawing vertically around the anchor point.<br>
 <br>
 Value <code>2</code> is assigned to <code>VCENTER</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.VCENTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="LEFT"><!-- --></A><H3>
LEFT</H3>
<PRE>
public static final int <B>LEFT</B></PRE>
<DL>
<DD>Constant for positioning the left side of the drawing at the anchor point.<br>
 <br>
 Value <code>4</code> is assigned to <code>LEFT</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.LEFT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RIGHT"><!-- --></A><H3>
RIGHT</H3>
<PRE>
public static final int <B>RIGHT</B></PRE>
<DL>
<DD>Constant for positioning the right side of the drawing at the anchor point.<br>
 <br>
 Value <code>8</code> is assigned to <code>RIGHT</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.RIGHT">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="TOP"><!-- --></A><H3>
TOP</H3>
<PRE>
public static final int <B>TOP</B></PRE>
<DL>
<DD>Constant for positioning the top of the drawing at the anchor point.<br>
 <br>
 Value <code>16</code> is assigned to <code>TOP</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.TOP">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BOTTOM"><!-- --></A><H3>
BOTTOM</H3>
<PRE>
public static final int <B>BOTTOM</B></PRE>
<DL>
<DD>Constant for positioning the bottom of the drawing at the anchor point.<br>
 <br>
 Value <code>32</code> is assigned to <code>BOTTOM</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.BOTTOM">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="BASELINE"><!-- --></A><H3>
BASELINE</H3>
<PRE>
public static final int <B>BASELINE</B></PRE>
<DL>
<DD>Constant for positioning the baseline of the text at the anchor point.<br>
 <br>
 Value <code>64</code> is assigned to <code>BASELINE</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.BASELINE">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="SOLID"><!-- --></A><H3>
SOLID</H3>
<PRE>
public static final int <B>SOLID</B></PRE>
<DL>
<DD>Constant for the <code>SOLID</code> stroke style.<br>
 <br>
 Value <code>0</code> is assigned to <code>SOLID</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.SOLID">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="DOTTED"><!-- --></A><H3>
DOTTED</H3>
<PRE>
public static final int <B>DOTTED</B></PRE>
<DL>
<DD>Constant for the <code>DOTTED</code> stroke style.<br>
 <br>
 Value <code>1</code> is assigned to <code>DOTTED</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.DOTTED">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="RESET_FILTER"><!-- --></A><H3>
RESET_FILTER</H3>
<PRE>
public static final int <B>RESET_FILTER</B></PRE>
<DL>
<DD>Constant to apply any filter on the color.<br>
 <br>
 Value <code>0</code> is assigned to <code>RESET_FILTER</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.RESET_FILTER">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="PLUS"><!-- --></A><H3>
PLUS</H3>
<PRE>
public static final int <B>PLUS</B></PRE>
<DL>
<DD>Constant for the <code>PLUS</code> operator on the filter.<br>
 <br>
 Value <code>1</code> is assigned to <code>PLUS</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.PLUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="MINUS"><!-- --></A><H3>
MINUS</H3>
<PRE>
public static final int <B>MINUS</B></PRE>
<DL>
<DD>Constant for the <code>MINUS</code> operator on the filter.<br>
 <br>
 Value <code>2</code> is assigned to <code>MINUS</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.MINUS">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="OR"><!-- --></A><H3>
OR</H3>
<PRE>
public static final int <B>OR</B></PRE>
<DL>
<DD>Constant for the <code>OR</code> operator on the filter.<br>
 <br>
 Value <code>3</code> is assigned to <code>OR</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.OR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="AND"><!-- --></A><H3>
AND</H3>
<PRE>
public static final int <B>AND</B></PRE>
<DL>
<DD>Constant for the <code>AND</code> operator on the filter.<br>
 <br>
 Value <code>4</code> is assigned to <code>AND</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.AND">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="XOR"><!-- --></A><H3>
XOR</H3>
<PRE>
public static final int <B>XOR</B></PRE>
<DL>
<DD>Constant for the <code>XOR</code> operator on the filter.<br>
 <br>
 Value <code>5</code> is assigned to <code>XOR</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.XOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="INV_COLOR"><!-- --></A><H3>
INV_COLOR</H3>
<PRE>
public static final int <B>INV_COLOR</B></PRE>
<DL>
<DD>Constant for the <code>INV_COLOR</code> operator mask on the filter.<br>
 <br>
 Value <code>0x10</code> is assigned to <code>INV_COLOR</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.INV_COLOR">Constant Field Values</A></DL>
</DL>
<HR>

<A NAME="INV_RESULT"><!-- --></A><H3>
INV_RESULT</H3>
<PRE>
public static final int <B>INV_RESULT</B></PRE>
<DL>
<DD>Constant for the <code>INV_RESULT</code> operator mask on the filter.<br>
 <br>
 Value <code>0x20</code> is assigned to <code>INV_RESULT</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/GraphicsContext.html#setFilter(int, int)"><CODE>setFilter(int, int)</CODE></A>, 
<A HREF="../../../constant-values.html#ej.microui.io.GraphicsContext.INV_RESULT">Constant Field Values</A></DL>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="GraphicsContext()"><!-- --></A><H3>
GraphicsContext</H3>
<PRE>
<B>GraphicsContext</B>()</PRE>
<DL>
<DD>Forbidden constructor: use <A HREF="../../../ej/microui/io/Display.html#getNewGraphicsContext()"><CODE>Display.getNewGraphicsContext()</CODE></A>
 to get an instance of <code>GraphicsContext</code>.
<P>
<DL>
<DT><B>See Also:</B><DD><A HREF="../../../ej/microui/io/Display.html#getNewGraphicsContext()"><CODE>Display.getNewGraphicsContext()</CODE></A>, 
<A HREF="../../../ej/microui/io/ComponentView.html#paint(ej.microui.io.GraphicsContext)"><CODE>ComponentView.paint(GraphicsContext)</CODE></A></DL>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" WIDTH="100%" CELLPADDING="3" CELLSPACING="0" SUMMARY="">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TH ALIGN="left" COLSPAN="1"><FONT SIZE="+2">
<B>Method Detail</B></FONT></TH>
</TR>
</TABLE>

<A NAME="translate(int, int)"><!-- --></A><H3>
translate</H3>
<PRE>
public final void <B>translate</B>(int&nbsp;x,
                            int&nbsp;y)</PRE>
<DL>
<DD>Translates the <code>GraphicsContext</code> origin with the given vector <code>(x,y)</code>.
 Subsequent rendering operations on the graphics context will be relative to the new origin.<br>
 <br>
 This method can be used to set an absolute origin to a <code>GraphicsContext</code>.
 For instance, the following code:<br>
 <code>g.translate(ax-g.getTranslateX(),ay-g.getTranslateY());</code><br>
 will set the origin of <code>g</code> at <code>(ax,ay)</code>.<br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the translation for the x coordinate<DD><CODE>y</CODE> - the translation for the y coordinate</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateX()"><!-- --></A><H3>
getTranslateX</H3>
<PRE>
public final int <B>getTranslateX</B>()</PRE>
<DL>
<DD>Returns the x coordinate of the translated origin of the graphics context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>x coordinate of the translated origin</DL>
</DD>
</DL>
<HR>

<A NAME="getTranslateY()"><!-- --></A><H3>
getTranslateY</H3>
<PRE>
public final int <B>getTranslateY</B>()</PRE>
<DL>
<DD>Returns the y coordinate of the translated origin of the graphics context.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>y coordinate of the translated origin</DL>
</DD>
</DL>
<HR>

<A NAME="setColor(int)"><!-- --></A><H3>
setColor</H3>
<PRE>
public final void <B>setColor</B>(int&nbsp;rgbColor)</PRE>
<DL>
<DD>Sets the current color.<br>
 Given value <code>rgbColor</code> is interpreted as a 24-bit RGB color,
 where the eight least significant bits matches the blue component, the next eight
 more significant bits matches the green component and the next eight more significant
 bits matches the red component.<br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbColor</CODE> - the color to set</DL>
</DD>
</DL>
<HR>

<A NAME="setFilter(int, int)"><!-- --></A><H3>
setFilter</H3>
<PRE>
public final void <B>setFilter</B>(int&nbsp;rgbFilter,
                            int&nbsp;operator)</PRE>
<DL>
<DD>Sets the current filter.<br>
 Given value <code>rgbFilter</code> is interpreted as a 24-bit RGB,
 where the eight least significant bits matches the blue component, the next eight
 more significant bits matches the green component and the next eight more significant
 bits matches the red component.<br>
 The filter is applied on each pixel drawn.<br>
 The operator is a combinaison between a binary operator and two unary operators:
 <ul>
 <li>binary operators are:
 <ul>
 <li>PLUS: perform a saturated addition between each color component (R, G, and B) and each
 corresponded filter component. If the result is higher than 0xff, the component is 0xff. The
 final color becomes so lighter.</li>
 <li>MINUS: perform a saturated substraction between each color component (R, G, and B) and each
 corresponded filter component. If the result is lower than 0x00, the component is 0x00. The
 final color becomes so darker</li>
 <li>OR: perform an 'OR' logical operation on each color component (R, G, or B) and each
 corresponded filter component.</li>
 <li>AND: perform an 'AND' logical operation on each color component (R, G, or B) and each
 corresponded filter component.</li>
 <li>XOR: perform an 'XOR' logical operation on each color component (R, G, or B) and each
 corresponded filter component.</li>
 </li>
 </ul>
 <li>unary operators are:
 <ul>
 <li>INV_COLOR: invert the source color before performing the filter operatorion.</li>
 <li>INV_RESULT: perform the filter operation and invert the resulted color.</li>
 </ul>
 </li>
 </ul>
 Examples:
 <ul>
 <li>AND | INV_COLOR: invert the source color and perform an 'AND' between the color and the
 filter.</li>
 <li>OR | INV_COLOR | INV_RESULT: invert the source color, perform an 'OR' between the color
 and the filter and invert the result.</li>
 <li>INV_COLOR: invert only the source color.</li>
 <li>INV_RESULT: idem as INV_COLOR.</li>
 <li>RESET_FILTER: remove the current filter, in this case, rgbFilter parameter is so useless.</li>
 </ul>
 A new filter erase previous one.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbFilter</CODE> - the filter to set<DD><CODE>operator</CODE> - the operator between the color and the filter</DL>
</DD>
</DL>
<HR>

<A NAME="getFilter(int, int)"><!-- --></A><H3>
getFilter</H3>
<PRE>
public final int <B>getFilter</B>(int&nbsp;rgbFilter,
                           int&nbsp;factor)</PRE>
<DL>
<DD>Gets a filter from the given filter and the given factor.<br>
 Given value <code>rgbFilter</code> is interpreted as a 24-bit RGB,
 where the eight least significant bits matches the blue component, the next eight
 more significant bits matches the green component and the next eight more significant
 bits matches the red component.<br>
 Each component of this filter is multiplied by the factor and the result is saturate to 0xff.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>rgbFilter</CODE> - the source filter<DD><CODE>factor</CODE> - the factor to apply to the filter, only the low significant byte is used.
<DT><B>Returns:</B><DD>the saturated filter</DL>
</DD>
</DL>
<HR>

<A NAME="getColor()"><!-- --></A><H3>
getColor</H3>
<PRE>
public final int <B>getColor</B>()</PRE>
<DL>
<DD>Returns the current color: a 24-bits value interpreted as: <code>0xRRGGBB</code>,
 that is, the eight least significant bits give the blue color, the next eight
 bits the green value and the next eight bits the red color.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current color</DL>
</DD>
</DL>
<HR>

<A NAME="getDisplayColor(int)"><!-- --></A><H3>
getDisplayColor</H3>
<PRE>
public final int <B>getDisplayColor</B>(int&nbsp;color)</PRE>
<DL>
<DD>Gets the color that will be displayed if the specified color is requested.<br>
 For example, with a monochrome display, this method will return either 0xFFFFFF (white) or
 0x000000 (black) depending on the brightness of the specified color.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>color</CODE> - the desired color in 0x00RRGGBB format.
<DT><B>Returns:</B><DD>the corresponding color that will be displayed on the graphics context (in 0x00RRGGBB format).</DL>
</DD>
</DL>
<HR>

<A NAME="setStrokeStyle(int)"><!-- --></A><H3>
setStrokeStyle</H3>
<PRE>
public final void <B>setStrokeStyle</B>(int&nbsp;style)</PRE>
<DL>
<DD>Sets the stroke style of the <code>GraphicsContext</code> used for drawing lines, arcs and rectangles.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>style</CODE> - either <code>SOLID</code> or <code>DOTTED</code>
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the style is not valid</DL>
</DD>
</DL>
<HR>

<A NAME="getStrokeStyle()"><!-- --></A><H3>
getStrokeStyle</H3>
<PRE>
public final int <B>getStrokeStyle</B>()</PRE>
<DL>
<DD>Returns the current stroke style.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>stroke style, <code>SOLID</code> or <code>DOTTED</code></DL>
</DD>
</DL>
<HR>

<A NAME="setFont(ej.microui.io.DisplayFont)"><!-- --></A><H3>
setFont</H3>
<PRE>
public final void <B>setFont</B>(<A HREF="../../../ej/microui/io/DisplayFont.html" title="class in ej.microui.io">DisplayFont</A>&nbsp;font)</PRE>
<DL>
<DD>Sets the font for subsequent text operations.
 If given font is <code>null</code>, the <code>GraphicsContext</code>'s font is set to
 <code>DisplayFont.getDefaultFont()</code>.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>font</CODE> - the new font to use</DL>
</DD>
</DL>
<HR>

<A NAME="getFont()"><!-- --></A><H3>
getFont</H3>
<PRE>
public final <A HREF="../../../ej/microui/io/DisplayFont.html" title="class in ej.microui.io">DisplayFont</A> <B>getFont</B>()</PRE>
<DL>
<DD>Returns the current font.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>current font</DL>
</DD>
</DL>
<HR>

<A NAME="clipRect(int, int, int, int)"><!-- --></A><H3>
clipRect</H3>
<PRE>
public final void <B>clipRect</B>(int&nbsp;x,
                           int&nbsp;y,
                           int&nbsp;width,
                           int&nbsp;height)</PRE>
<DL>
<DD>Sets the clipping area to be the intersection of the specified rectangle
 with the current clipping rectangle.
 It is legal to specify a clip rectangle whose width or height is zero or negative.
 In this case the clip is considered to be empty, that is, no pixels are contained
 within it. Therefore, if any graphics operations are issued under such a clip, no
 pixels will be modified.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle<DD><CODE>y</CODE> - the y coordinate of the rectangle<DD><CODE>width</CODE> - the width of the rectangle<DD><CODE>height</CODE> - the height of the rectangle</DL>
</DD>
</DL>
<HR>

<A NAME="setClip(int, int, int, int)"><!-- --></A><H3>
setClip</H3>
<PRE>
public final void <B>setClip</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height)</PRE>
<DL>
<DD>Sets the current clipping zone to the rectangle defined by the given location
 <code>(x,y)</code> and size <code>(width,height)</code>.
 Given width or height may be zero or negative, in that case the clip is considered
 to be empty, i.e. it contains no pixels. Nothing is done when drawing in an empty
 clip.
 Rendering operations have no effect outside of the clipping area.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the new clip rectangle<DD><CODE>y</CODE> - the y coordinate of the new clip rectangle<DD><CODE>width</CODE> - the width of the new clip rectangle<DD><CODE>height</CODE> - the height of the new clip rectangle</DL>
</DD>
</DL>
<HR>

<A NAME="getClipX()"><!-- --></A><H3>
getClipX</H3>
<PRE>
public final int <B>getClipX</B>()</PRE>
<DL>
<DD>Returns the x offset of the current clipping zone, relative to the graphics context's origin.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>x offset of the current clipping zone</DL>
</DD>
</DL>
<HR>

<A NAME="getClipY()"><!-- --></A><H3>
getClipY</H3>
<PRE>
public final int <B>getClipY</B>()</PRE>
<DL>
<DD>Returns the y offset of the current clipping zone, relative to graphics context's origin.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>y offset of the current clipping zone</DL>
</DD>
</DL>
<HR>

<A NAME="getClipWidth()"><!-- --></A><H3>
getClipWidth</H3>
<PRE>
public final int <B>getClipWidth</B>()</PRE>
<DL>
<DD>Returns the width of the current clipping zone.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>width of the current clipping zone</DL>
</DD>
</DL>
<HR>

<A NAME="getClipHeight()"><!-- --></A><H3>
getClipHeight</H3>
<PRE>
public final int <B>getClipHeight</B>()</PRE>
<DL>
<DD>Returns the height of the current clipping zone.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>height of the current clipping zone.</DL>
</DD>
</DL>
<HR>

<A NAME="drawPixel(int, int)"><!-- --></A><H3>
drawPixel</H3>
<PRE>
public final void <B>drawPixel</B>(int&nbsp;x,
                            int&nbsp;y)</PRE>
<DL>
<DD>Draws a pixel at <code>(x,y)</code> using the current color.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the pixel<DD><CODE>y</CODE> - the y coordinate of the pixel</DL>
</DD>
</DL>
<HR>

<A NAME="readPixel(int, int)"><!-- --></A><H3>
readPixel</H3>
<PRE>
public final int <B>readPixel</B>(int&nbsp;x,
                           int&nbsp;y)</PRE>
<DL>
<DD>Obtains the RGB color of the pixel at <code>(x,y)</code>.  The read color may be different than the
 drawing color. It is screen dependent, according to the number of bits per pixels
 (see <A HREF="../../../ej/microui/io/Display.html#getBPP()"><CODE>Display.getBPP()</CODE></A>).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the pixel<DD><CODE>y</CODE> - the y coordinate of the pixel
<DT><B>Returns:</B><DD>the rgb color of the pixel</DL>
</DD>
</DL>
<HR>

<A NAME="drawHorizontalLine(int, int, int)"><!-- --></A><H3>
drawHorizontalLine</H3>
<PRE>
public final void <B>drawHorizontalLine</B>(int&nbsp;x,
                                     int&nbsp;y,
                                     int&nbsp;width)</PRE>
<DL>
<DD>Draws an horizontal line from <code>(x,y)</code> to <code>(x+width,y)</code> using
 the current color and stroke style.
 The drawn line counts <code>(width+1)</code> pixels.<br>
 If <code>width</code> is negative, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the start of the line<DD><CODE>y</CODE> - the y coordinate of the start of the line<DD><CODE>width</CODE> - the width of the horizontal line to draw</DL>
</DD>
</DL>
<HR>

<A NAME="drawVerticalLine(int, int, int)"><!-- --></A><H3>
drawVerticalLine</H3>
<PRE>
public final void <B>drawVerticalLine</B>(int&nbsp;x,
                                   int&nbsp;y,
                                   int&nbsp;height)</PRE>
<DL>
<DD>Draws a vertical line from <code>(x,y)</code> to <code>(x,y+height-1)</code> using
 the current color and stroke style.
 The drawn line counts <code>(height+1)</code> pixels.<br>
 If <code>height</code> is negative, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the start of the line<DD><CODE>y</CODE> - the y coordinate of the start of the line<DD><CODE>height</CODE> - the width of the vertical line to draw</DL>
</DD>
</DL>
<HR>

<A NAME="drawLine(int, int, int, int)"><!-- --></A><H3>
drawLine</H3>
<PRE>
public final void <B>drawLine</B>(int&nbsp;x1,
                           int&nbsp;y1,
                           int&nbsp;x2,
                           int&nbsp;y2)</PRE>
<DL>
<DD>Draws a line from <code>(x1,y1)</code> to <code>(x2,y2)</code> using the current
 color and stroke style.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x1</CODE> - the x coordinate of the start of the line<DD><CODE>y1</CODE> - the y coordinate of the start of the line<DD><CODE>x2</CODE> - the x coordinate of the end of the line<DD><CODE>y2</CODE> - the y coordinate of the end of the line</DL>
</DD>
</DL>
<HR>

<A NAME="drawRect(int, int, int, int)"><!-- --></A><H3>
drawRect</H3>
<PRE>
public final void <B>drawRect</B>(int&nbsp;x,
                           int&nbsp;y,
                           int&nbsp;width,
                           int&nbsp;height)</PRE>
<DL>
<DD>Draws the outline of the specified rectangle using the current color and stroke style.
 The drawn rectangle includes <code>(width+1)*(height+1)</code> pixels.<br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to draw<DD><CODE>y</CODE> - the y coordinate of the rectangle to draw<DD><CODE>width</CODE> - the width of the rectangle to draw<DD><CODE>height</CODE> - the height of the rectangle to draw</DL>
</DD>
</DL>
<HR>

<A NAME="fillRect(int, int, int, int)"><!-- --></A><H3>
fillRect</H3>
<PRE>
public final void <B>fillRect</B>(int&nbsp;x,
                           int&nbsp;y,
                           int&nbsp;width,
                           int&nbsp;height)</PRE>
<DL>
<DD>Fills the specified rectangle with the current color.
 If either <code>width</code> or <code>height</code> is negative or zero,
 nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to be filled<DD><CODE>y</CODE> - the y coordinate of the rectangle to be filled<DD><CODE>width</CODE> - the width of the rectangle to be filled<DD><CODE>height</CODE> - the height of the rectangle to be filled</DL>
</DD>
</DL>
<HR>

<A NAME="drawRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
drawRoundRect</H3>
<PRE>
public final void <B>drawRoundRect</B>(int&nbsp;x,
                                int&nbsp;y,
                                int&nbsp;width,
                                int&nbsp;height,
                                int&nbsp;arcWidth,
                                int&nbsp;arcHeight)</PRE>
<DL>
<DD>Draws the outline of the specified rounded corner rectangle using the
 current color and stroke style.
 Drawn rectangle is <code>width+1</code>-pixel wide and <code>height+1</code>-pixel high.
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to draw<DD><CODE>y</CODE> - the y coordinate of the rectangle to draw<DD><CODE>width</CODE> - the width of the rectangle to draw<DD><CODE>height</CODE> - the height of the rectangle to draw<DD><CODE>arcWidth</CODE> - the horizontal diameter of the arc at the corners<DD><CODE>arcHeight</CODE> - the vertical diameter of the arc at the corners</DL>
</DD>
</DL>
<HR>

<A NAME="fillRoundRect(int, int, int, int, int, int)"><!-- --></A><H3>
fillRoundRect</H3>
<PRE>
public final void <B>fillRoundRect</B>(int&nbsp;x,
                                int&nbsp;y,
                                int&nbsp;width,
                                int&nbsp;height,
                                int&nbsp;arcWidth,
                                int&nbsp;arcHeight)</PRE>
<DL>
<DD>Fills the specified rounded corner rectangle with the current color.
 If either <code>width</code> or <code>height</code> is negative or zero, nothing is drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the rectangle to fill<DD><CODE>y</CODE> - the y coordinate of the rectangle to fill<DD><CODE>width</CODE> - the width of the rectangle to fill<DD><CODE>height</CODE> - the height of the rectangle to fill<DD><CODE>arcWidth</CODE> - the horizontal diameter of the arc at the corners<DD><CODE>arcHeight</CODE> - the vertical diameter of the arc at the corners</DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(int[])"><!-- --></A><H3>
drawPolygon</H3>
<PRE>
public final void <B>drawPolygon</B>(int[]&nbsp;xys)</PRE>
<DL>
<DD>Draws the closed polygon which is defined by the array of integer coordinates, using the current color and
 stroke style. Lines are drawn between each consecutive pair, and between the first pair and last pair in the array.
 The effect is identical to<br>
 <code>drawPolygon(xys,0,xys.length);</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xys</CODE> - the array of coordinates : x1,y1,......xn,yn.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <code>xys</code> array is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>xys</code> length is odd.</DL>
</DD>
</DL>
<HR>

<A NAME="drawPolygon(int[], int, int)"><!-- --></A><H3>
drawPolygon</H3>
<PRE>
public final void <B>drawPolygon</B>(int[]&nbsp;xys,
                              int&nbsp;offset,
                              int&nbsp;length)</PRE>
<DL>
<DD>Draws the closed polygon which is defined by the array of integer coordinates, using the current color and
 stroke style. Lines are drawn between each consecutive pair, and between the first pair and last pair in the array.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xys</CODE> - the array of coordinates : x1,y1,......xn,yn.<DD><CODE>offset</CODE> - the <code>x1</code> index in <code>xys</code>.<DD><CODE>length</CODE> - the number of coordinates, must be even.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <code>xys</code> array is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>xys</code> length is odd.
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - the wanted data is outside the array bounds.</DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(int[])"><!-- --></A><H3>
fillPolygon</H3>
<PRE>
public final void <B>fillPolygon</B>(int[]&nbsp;xys)</PRE>
<DL>
<DD>Fills the closed polygon which is defined by the array of integer coordinates, using the current color.
 Lines are drawn between each consecutive pair, and between the first pair and last pair in the array.
 The lines connecting each pair of points are included in the filled polygon.
 The effect is identical to<br>
 <code>fillPolygon(xys,0,xys.length);</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xys</CODE> - the array of coordinates : x1,y1,......xn,yn.
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <code>xys</code> array is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>xys</code> length is odd.</DL>
</DD>
</DL>
<HR>

<A NAME="fillPolygon(int[], int, int)"><!-- --></A><H3>
fillPolygon</H3>
<PRE>
public final void <B>fillPolygon</B>(int[]&nbsp;xys,
                              int&nbsp;offset,
                              int&nbsp;length)</PRE>
<DL>
<DD>Fills the closed polygon which is defined by the array of integer coordinates, using the current color.
 Lines are drawn between each consecutive pair, and between the first pair and last pair in the array.
 The lines connecting each pair of points are included in the filled polygon.
 The effect is identical to<br>
 <code>fillPolygon(xys,0,xys.length);</code>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>xys</CODE> - the array of coordinates : x1,y1,......xn,yn.<DD><CODE>offset</CODE> - the <code>x1</code> index in <code>xys</code>.<DD><CODE>length</CODE> - the number of coordinates, must be even.
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if <code>offset</code> and <code>length</code> do not specify a valid range within <code>xys</code>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <code>xys</code> array is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>xys</code> length is odd.</DL>
</DD>
</DL>
<HR>

<A NAME="drawArc(int, int, int, int, int, int)"><!-- --></A><H3>
drawArc</H3>
<PRE>
public final void <B>drawArc</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;startAngle,
                          int&nbsp;arcAngle)</PRE>
<DL>
<DD>Draws the outline of a circular or elliptical arc covering the specified
 rectangle, using the current color and stroke style.<br>
 <br>
 The arc is drawn from <code>startAngle</code> up to <code>arcAngle</code> degrees.
 The center of the arc is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 <br>
 Angles are interpreted such that 0 degrees is at the 3 o'clock position. A positive value
 indicates a counter-clockwise rotation while a negative value indicates a clockwise rotation.<br>
 <br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.<br>
 <br>
 The angles are given relative to the rectangle. For instance an angle of
 45 degrees is always defined by the line from the center of the rectangle to the upper right corner
 of the rectangle. Thus for a non squarred rectangle angles are skewed along either height or width.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the upper-left corner of the rectangle where the arc is drawn<DD><CODE>y</CODE> - the y coordinate of the upper-left corner of the rectangle where the arc is drawn<DD><CODE>width</CODE> - the width of the arc to draw<DD><CODE>height</CODE> - the height of the arc to draw<DD><CODE>startAngle</CODE> - the beginning angle of the arc to draw<DD><CODE>arcAngle</CODE> - the angular extent of the arc from <code>startAngle</code></DL>
</DD>
</DL>
<HR>

<A NAME="fillArc(int, int, int, int, int, int)"><!-- --></A><H3>
fillArc</H3>
<PRE>
public final void <B>fillArc</B>(int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height,
                          int&nbsp;startAngle,
                          int&nbsp;arcAngle)</PRE>
<DL>
<DD>Fills a circular or elliptical arc covering the specified rectangle with the current color.<br>
 <br>
 The arc is drawn from <code>startAngle</code> up to <code>arcAngle</code> degrees.
 The center of the arc is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 <br>
 Angles are interpreted such that 0 degrees is at the 3 o'clock position. A positive value
 indicates a counter-clockwise rotation while a negative value indicates a clockwise rotation.<br>
 <br>
 This method fills the area bounded from the center of the arc to the arc itself.<br>
 <br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.<br>
 <br>
 The angles are given relatively to the rectangle. That is to say that the angle of
 45 degrees is always defined by the line from the center of the rectangle to the upper-right corner
 of the rectangle. Thus for a non squarred rectangle angles are skewed along either height or width.<br>
 <br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the upper-left corner of the rectangle where the arc is filled.<DD><CODE>y</CODE> - the y coordinate of the upper-left corner of the rectangle where the arc is filled.<DD><CODE>width</CODE> - the width of the arc to fill<DD><CODE>height</CODE> - the height of the arc to fill<DD><CODE>startAngle</CODE> - the beginning angle of the arc to draw<DD><CODE>arcAngle</CODE> - the angular extent of the arc from <code>startAngle</code></DL>
</DD>
</DL>
<HR>

<A NAME="drawCircle(int, int, int)"><!-- --></A><H3>
drawCircle</H3>
<PRE>
public final void <B>drawCircle</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;diameter)</PRE>
<DL>
<DD>Draws the outline of a circle covering the rectangle specified by its diameter, using the current color
 and stroke style.<br>
 <br>
 The center of the circle is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>diameter</code>.<br>
 <br>
 If <code>diameter</code> is negative, nothing is drawn.<br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the upper-left corner of the rectangle where the circle is drawn<DD><CODE>y</CODE> - the y coordinate of the upper-left corner of the rectangle where the circle is drawn<DD><CODE>diameter</CODE> - the diameter of the circle to draw</DL>
</DD>
</DL>
<HR>

<A NAME="fillCircle(int, int, int)"><!-- --></A><H3>
fillCircle</H3>
<PRE>
public final void <B>fillCircle</B>(int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;diameter)</PRE>
<DL>
<DD>Fills a circle covering the rectangle specified by its diameter with the current color.<br>
 <br>
 The center of the circle is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>diameter</code>.<br>
 <br>
 If <code>diameter</code> is negative, nothing is drawn.<br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the upper-left corner of the rectangle where the circle is filled.<DD><CODE>y</CODE> - the y coordinate of the upper-left corner of the rectangle where the circle is filled.<DD><CODE>diameter</CODE> - the diameter of the circle to fill</DL>
</DD>
</DL>
<HR>

<A NAME="drawEllipse(int, int, int, int)"><!-- --></A><H3>
drawEllipse</H3>
<PRE>
public final void <B>drawEllipse</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>Draws the outline of a ellipse covering the specified rectangle, using the current color
 and stroke style.<br>
 <br>
 The center of the ellipse is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 <br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.<br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the upper-left corner of the rectangle where the ellipse is drawn<DD><CODE>y</CODE> - the y coordinate of the upper-left corner of the rectangle where the ellipse is drawn<DD><CODE>width</CODE> - the width of the ellipse to draw<DD><CODE>height</CODE> - the height of the ellipse to draw</DL>
</DD>
</DL>
<HR>

<A NAME="fillEllipse(int, int, int, int)"><!-- --></A><H3>
fillEllipse</H3>
<PRE>
public final void <B>fillEllipse</B>(int&nbsp;x,
                              int&nbsp;y,
                              int&nbsp;width,
                              int&nbsp;height)</PRE>
<DL>
<DD>Fills a ellipse covering the specified rectangle with the current color.<br>
 <br>
 The center of the ellipse is defined as the center of the rectangle whose origin is at <code>(x,y)</code>
 (upper-left corner) and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 <br>
 If either <code>width</code> or <code>height</code> is negative, nothing is drawn.<br>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x</CODE> - the x coordinate of the upper-left corner of the rectangle where the ellipse is filled.<DD><CODE>y</CODE> - the y coordinate of the upper-left corner of the rectangle where the ellipse is filled.<DD><CODE>width</CODE> - the width of the ellipse to fill<DD><CODE>height</CODE> - the height of the ellipse to fill</DL>
</DD>
</DL>
<HR>

<A NAME="drawImage(ej.microui.io.Image, int, int, int)"><!-- --></A><H3>
drawImage</H3>
<PRE>
public final void <B>drawImage</B>(<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io">Image</A>&nbsp;img,
                            int&nbsp;x,
                            int&nbsp;y,
                            int&nbsp;anchor)</PRE>
<DL>
<DD>Draws an image at the given anchor point.<br>
 The image anchor point is at position <code>(x,y)</code>.
 Position constants may be given to specify the precise location of the image around the anchor point.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the image to draw<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - position of the image around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>anchor</code> is not a valid value (<code>BASELINE</code> is illegal).
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>img</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>img</code> and this <code>GraphicsContext</code> target different displays</DL>
</DD>
</DL>
<HR>

<A NAME="drawDeformedImage(ej.microui.io.Image, int, int, int[], int)"><!-- --></A><H3>
drawDeformedImage</H3>
<PRE>
public final void <B>drawDeformedImage</B>(<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io">Image</A>&nbsp;img,
                                    int&nbsp;x,
                                    int&nbsp;y,
                                    int[]&nbsp;xys,
                                    int&nbsp;anchor)</PRE>
<DL>
<DD>Draws a deformed image at the given anchor point.<br>
 The image anchor point is at position <code>(x,y)</code>.
 Position constants may be given to specify the precise location of the image around the anchor point.<br>
 <br>
 The deformed image is identified by its four corner points.
 These points are defined by the array of integer coordinates and they must respect the following order:
 first is the top-left corner, second is the top-right, third is the bottom-right and fourth is the bottom-left.<br>
 <br>
 Examples with img an image and imgWidth and imgHeight its size.<br>
 <li>To draw normal img, the array should be : {0, 0, imgWidth-1, 0, imgWidth-1, imgHeight-1, 0, imgHeight-1}.</li>
 <li>To draw img with a rotation clockwise by 90 degrees, the array should be : {imgHeight-1, 0, imgHeight-1, imgWidth-1, 0, imgWidth-1, 0, 0}.</li>
 <li>To draw img mirrored about the vertical axis, the array should be : {0, 0, -(imgWidth-1), 0, -(imgWidth-1), -(imgHeight-1), 0, -(imgHeight-1)}.</li>
 <li>To draw img with a double scale, the array should be : {0, 0, (imgWidth-1)*2, 0, (imgWidth-1)*2, (imgHeight-1)*2, 0, (imgHeight-1)*2}.</li>
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>img</CODE> - the image to draw<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>xys</CODE> - the array of coordinates : x1,y1,x2,y2,x3,y3,x4,y4.<DD><CODE>anchor</CODE> - position of the image around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>img</code> is <code>null</code>
<DD><CODE>java.lang.NullPointerException</CODE> - if the <code>xys</code> array is null.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the <code>xys</code> length is different than 2*4.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>img</code> and this <code>GraphicsContext</code> target different displays</DL>
</DD>
</DL>
<HR>

<A NAME="drawRegion(ej.microui.io.Image, int, int, int, int, int, int, int)"><!-- --></A><H3>
drawRegion</H3>
<PRE>
public final void <B>drawRegion</B>(<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io">Image</A>&nbsp;src,
                             int&nbsp;x_src,
                             int&nbsp;y_src,
                             int&nbsp;width,
                             int&nbsp;height,
                             int&nbsp;x_dest,
                             int&nbsp;y_dest,
                             int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the specified region of an image.
 The region in <code>src</code> is given relative to the image (origin at the upper-left corner)
 as a rectangle whose origin is at <code>(x_src,y_src)</code> and whose dimension is given by
 <code>width</code> and <code>height</code>.<br>
 <br>
 The image region anchor point in destination is at the relative position <code>(x_dest,y_dest)</code>.
 Position constants may be given to specify the precise location of the image around the anchor point.<br>
 <br>
 If the specified source region exceeds the image bounds, the copied region is limited to the
 image boundary.
 If the copied region goes out of the bounds of the <code>GraphicsContext</code> area, pixels out of the
 range will not be drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>src</CODE> - the image to copy from<DD><CODE>x_src</CODE> - the x coordinate of the upper-left corner of the region to copy<DD><CODE>y_src</CODE> - the y coordinate of the upper-left corner of the region to copy<DD><CODE>width</CODE> - the width of the region to copy<DD><CODE>height</CODE> - the height of the region to copy<DD><CODE>x_dest</CODE> - the x coordinate of the anchor point in the destination<DD><CODE>y_dest</CODE> - the y coordinate of the anchor point in the destination<DD><CODE>anchor</CODE> - position of the region around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>src</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not valid
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if <code>src</code> and this <code>GraphicsContext</code> target different displays</DL>
</DD>
</DL>
<HR>

<A NAME="copyArea(int, int, int, int, int, int, int)"><!-- --></A><H3>
copyArea</H3>
<PRE>
public final void <B>copyArea</B>(int&nbsp;x_src,
                           int&nbsp;y_src,
                           int&nbsp;width,
                           int&nbsp;height,
                           int&nbsp;x_dest,
                           int&nbsp;y_dest,
                           int&nbsp;anchor)</PRE>
<DL>
<DD>Copies an area within a <code>GraphicsContext</code>.
 The region to copy is specified as rectangular area whose origin is at <code>(x_src,y_src)</code>
 and whose dimension is given by <code>width</code> and <code>height</code>.<br>
 The destination is defined by an anchor point at <code>(x_dest,y_dest)</code>.
 Position constants may be given to specify the precise location of the area around the anchor point.<br>
 <br>
 If the specified source region exceeds the clipping rectangle, the copied region is limited to the
 clipping rectangle.
 If the copied region goes out of the bounds of the <code>GraphicsContext</code> area, pixels out of the
 range will not be drawn.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>x_src</CODE> - the x coordinate of upper-left corner of source area<DD><CODE>y_src</CODE> - the y coordinate of upper-left corner of source area<DD><CODE>width</CODE> - the width of the source area<DD><CODE>height</CODE> - the height of the source area<DD><CODE>x_dest</CODE> - the x coordinate of the destination anchor point<DD><CODE>y_dest</CODE> - the y coordinate of the destination anchor point<DD><CODE>anchor</CODE> - position of the region around the anchor point within the destination image
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not valid, or if destination (aka 'this' object)
 is a GraphicsContext of a Screen.</DL>
</DD>
</DL>
<HR>

<A NAME="getARGB(int[], int, int, int, int, int, int)"><!-- --></A><H3>
getARGB</H3>
<PRE>
public final void <B>getARGB</B>(int[]&nbsp;argbData,
                          int&nbsp;offset,
                          int&nbsp;scanlength,
                          int&nbsp;x,
                          int&nbsp;y,
                          int&nbsp;width,
                          int&nbsp;height)</PRE>
<DL>
<DD>Obtains ARGB pixel data from the specified region of this graphics context and stores it
 in the provided array of integers. Each pixel value is stored in <code>0xAARRGGBB</code> format,
 where the high-order byte contains the alpha channel and the remaining bytes contain
 color components for red, green and blue, respectively. The alpha channel specifies
 the opacity of the pixel, where a value of <code>0x00</code>  represents a pixel that is fully
 transparent and a value of <code>0xFF</code> represents a fully opaque pixel.<br>
 <br>
 Color values may be resampled to reflect the display capabilities of the device (for example,
 red, green or blue pixels may all be represented by the same gray value on a grayscale device).<br>
 <br>
 The <code>scanlength</code> specifies the relative offset within the array between
 the corresponding pixels of consecutive rows. In order to prevent rows of stored pixels
 from overlapping, the absolute value of <code>scanlength</code> must be greater than or
 equal to <code>width</code>. Negative values of <code>scanlength</code> are allowed.
 In all cases, this must result in every reference being within the bounds of
 the <code>rgbData</code> array.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argbData</CODE> - an array of integers in which the ARGB pixel data is stored<DD><CODE>offset</CODE> - the index into the array where the first ARGB value is stored<DD><CODE>scanlength</CODE> - the relative offset in the array between corresponding pixels in consecutive rows of the region<DD><CODE>x</CODE> - the x-coordinate of the upper left corner of the region<DD><CODE>y</CODE> - the y-coordinate of the upper left corner of the region<DD><CODE>width</CODE> - the width of the region<DD><CODE>height</CODE> - the height of the region
<DT><B>Throws:</B>
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation
 would attempt to access an element in the <code>rgbData</code> array whose
 index is either negative or beyond its length (the contents of the array are unchanged)
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the area being retrieved exceeds the bounds of the source graphics context
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the absolute value of <code>scanlength</code> is less than <code>width</code>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>rgbData</code> is null</DL>
</DD>
</DL>
<HR>

<A NAME="drawARGB(int[], int, int, int, int, int, int, int)"><!-- --></A><H3>
drawARGB</H3>
<PRE>
public void <B>drawARGB</B>(int[]&nbsp;argbData,
                     int&nbsp;offset,
                     int&nbsp;scanlength,
                     int&nbsp;x,
                     int&nbsp;y,
                     int&nbsp;width,
                     int&nbsp;height,
                     int&nbsp;anchor)</PRE>
<DL>
<DD>Gets ARGB pixel data from the provided array of integers and draws it in the specified region of this graphics
 context. Each pixel value is stored in <code>0xAARRGGBB</code> format, where the high-order byte contains the
 alpha channel and the remaining bytes contain color components for red, green and blue, respectively. The alpha
 channel specifies the opacity of the pixel, where a value of <code>0x00</code>  represents a pixel that is fully
 transparent and a value of <code>0xFF</code> represents a fully opaque pixel.<br>
 <br>
 Color values may be resampled to reflect the display capabilities of the device (for example,
 red, green or blue pixels may all be represented by the same gray value on a grayscale device).<br>
 <br>
 The <code>scanlength</code> specifies the relative offset within the array between
 the corresponding pixels of consecutive rows. In order to prevent rows of stored pixels
 from overlapping, the absolute value of <code>scanlength</code> must be greater than or
 equal to <code>width</code>. Negative values of <code>scanlength</code> are allowed.
 In all cases, this must result in every reference being within the bounds of
 the <code>rgbData</code> array.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>argbData</CODE> - an array of integers in which the ARGB pixel data is stored<DD><CODE>offset</CODE> - the index into the array where the first ARGB value is stored<DD><CODE>scanlength</CODE> - the relative offset in the array between corresponding pixels in consecutive rows of the region<DD><CODE>x</CODE> - the x coordinate of the anchor point in the destination<DD><CODE>y</CODE> - the x coordinate of the anchor point in the destination<DD><CODE>width</CODE> - the width of the region<DD><CODE>height</CODE> - the height of the region<DD><CODE>anchor</CODE> - position of the region around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>argbData</code> is <code>null</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not valid
<DD><CODE>java.lang.ArrayIndexOutOfBoundsException</CODE> - if the requested operation
 would attempt to access an element in the <code>argbData</code> array whose
 index is either negative or beyond its length.
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if the absolute value of <code>scanlength</code> is less than <code>width</code></DL>
</DD>
</DL>
<HR>

<A NAME="drawString(java.lang.String, int, int, int)"><!-- --></A><H3>
drawString</H3>
<PRE>
public final void <B>drawString</B>(java.lang.String&nbsp;str,
                             int&nbsp;x,
                             int&nbsp;y,
                             int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the string using the current font and color.<br>
 The text anchor point is at position <code>(x,y)</code>.
 Position constants may be given to specify the precise location of the text around the anchor point.<br>
 <br>
 See <A HREF="../../../ej/microui/io/GraphicsContext.html" title="class in ej.microui.io"><CODE>GraphicsContext</CODE></A> for details of anchors.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - the string to draw<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - position of the text around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.NullPointerException</CODE> - if str is null
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not a valid value</DL>
</DD>
</DL>
<HR>

<A NAME="drawSubstring(java.lang.String, int, int, int, int, int)"><!-- --></A><H3>
drawSubstring</H3>
<PRE>
public final void <B>drawSubstring</B>(java.lang.String&nbsp;str,
                                int&nbsp;offset,
                                int&nbsp;len,
                                int&nbsp;x,
                                int&nbsp;y,
                                int&nbsp;anchor)</PRE>
<DL>
<DD>Draws the string from <code>offset</code> to <code>offset+length</code> using the current font and color.<br>
 The text anchor point is at position <code>(x,y)</code>.
 Position constants may be given to specify the precise location of the text around the anchor point.<br>
 <br>
 See <A HREF="../../../ej/microui/io/GraphicsContext.html" title="class in ej.microui.io"><CODE>GraphicsContext</CODE></A> for details of anchors.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>str</CODE> - the string to draw<DD><CODE>offset</CODE> - index of the first character in the string to draw<DD><CODE>len</CODE> - number of characters to draw from <code>offset</code><DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - position of the string text around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.StringIndexOutOfBoundsException</CODE> - if <code>offset</code> and <code>length</code> do not specify a valid range within <code>str</code>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not a valid value
<DD><CODE>java.lang.NullPointerException</CODE> - if <code>str</code> is <code>null</code></DL>
</DD>
</DL>
<HR>

<A NAME="drawChar(char, int, int, int)"><!-- --></A><H3>
drawChar</H3>
<PRE>
public final void <B>drawChar</B>(char&nbsp;character,
                           int&nbsp;x,
                           int&nbsp;y,
                           int&nbsp;anchor)</PRE>
<DL>
<DD>Draws a character using the current font and color.<br>
 The text anchor point is at position <code>(x,y)</code>.
 Position constants may be given to specify the precise location of the character around the anchor point.
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>character</CODE> - the character to draw<DD><CODE>x</CODE> - the x coordinate of the anchor point<DD><CODE>y</CODE> - the y coordinate of the anchor point<DD><CODE>anchor</CODE> - position of the character around the anchor point
<DT><B>Throws:</B>
<DD><CODE>java.lang.IllegalArgumentException</CODE> - if anchor is not a valid value</DL>
</DD>
</DL>
<HR>

<A NAME="setEllipsis(boolean)"><!-- --></A><H3>
setEllipsis</H3>
<PRE>
public void <B>setEllipsis</B>(boolean&nbsp;enable)</PRE>
<DL>
<DD>Enables (disables) truncation when rendering characters.
 When enabled, a text that would be outside the current clip will have its last
 visible character replaced by ellipsis (three dots).
<P>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>enable</CODE> - true to enable the ellipsis mode</DL>
</DD>
</DL>
<HR>

<A NAME="getDisplay()"><!-- --></A><H3>
getDisplay</H3>
<PRE>
public <A HREF="../../../ej/microui/io/Display.html" title="class in ej.microui.io">Display</A> <B>getDisplay</B>()</PRE>
<DL>
<DD>Returns the display associated with the GraphicsContext.
<P>
<DD><DL>

<DT><B>Returns:</B><DD>the display associated with the GraphicsContext</DL>
</DD>
</DL>
<HR>

<A NAME="getEllipsis()"><!-- --></A><H3>
getEllipsis</H3>
<PRE>
public boolean <B>getEllipsis</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if the truncation mechanism is enabled.
<P>
<DD><DL>

<DT><B>Returns:</B><DD><code>true</code> if the truncation mechanism is enabled.</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>


<!-- ======= START OF BOTTOM NAVBAR ====== -->
<A NAME="navbar_bottom"><!-- --></A>
<A HREF="#skip-navbar_bottom" title="Skip navigation links"></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0" SUMMARY="">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3" SUMMARY="">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="class-use/GraphicsContext.html"><FONT CLASS="NavBarFont1"><B>Use</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-files/index-1.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../ej/microui/io/Font.html" title="class in ej.microui.io"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../ej/microui/io/Image.html" title="class in ej.microui.io"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html?ej/microui/io/GraphicsContext.html" target="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="GraphicsContext.html" target="_top"><B>NO FRAMES</B></A>  &nbsp;
&nbsp;<SCRIPT type="text/javascript">
  <!--
  if(window==top) {
    document.writeln('<A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>');
  }
  //-->
</SCRIPT>
<NOSCRIPT>
  <A HREF="../../../allclasses-noframe.html"><B>All Classes</B></A>
</NOSCRIPT>


</FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY:&nbsp;NESTED&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL:&nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<A NAME="skip-navbar_bottom"></A>
<!-- ======== END OF BOTTOM NAVBAR ======= -->

<HR>

</BODY>
</HTML>
